Migration Plan: From Single-File HTML to a Nuxt 3 Application
This document outlines the strategy for migrating the Teller.eu.org digital fortune teller from a single HTML file to a full-featured, SEO-friendly Nuxt 3 application. The primary goals are to improve code organization, implement localized routing (e.g., /fr/tarot/), enhance maintainability, and boost performance using Nuxt 3.
Phase 1: Project Scaffolding and Foundational Setup
Initialize Nuxt 3 Project:
Create a new Nuxt 3 project: Done.
Install necessary modules: npm install -D @nuxtjs/i18n.
Establish Directory Structure:
pages/: Will handle the content of each section. We will use a dynamic routing structure to manage the different "tool" pages.
layouts/: The common UI (header, footer/nav) will reside in a default layout.
components/: The UI will be broken down into smaller, reusable Vue components.
composables/: Reusable logic, such as data fetching and calculations, will be extracted into composables.
plugins/: For integrating third-party libraries like anime.js.
assets/: For global CSS and other static assets.
(Revised) locales/: Will store translation files (e.g., en.json, fr.json) for the @nuxtjs/i18n module.
(Revised) Configure Nuxt for Localized Routing:
In nuxt.config.ts, configure the @nuxtjs/i18n module. This is the most critical step for achieving the /fr/tarot/ URL structure.
// nuxt.config.ts
export default defineNuxtConfig({
  modules: ['@nuxtjs/i18n'],
  i18n: {
    locales: [
      { code: 'en', iso: 'en-US', file: 'en.json', name: 'English' },
      { code: 'fr', iso: 'fr-FR', file: 'fr.json', name: 'Français' },
      { code: 'zh', iso: 'zh-CN', file: 'zh.json', name: '中文' },
      { code: 'hi', iso: 'hi-IN', file: 'hi.json', name: 'हिन्दी' },
      { code: 'ar', iso: 'ar-SA', file: 'ar.json', name: 'العربية', dir: 'rtl' },
    ],
    lazy: true, // Load translation files on demand
    langDir: 'locales',
    defaultLocale: 'en',
    strategy: 'prefix_except_default', // Default lang 'en' will be at '/', others at '/fr/', '/zh/'
    vueI18n: './i18n.config.ts', // <-- Separate config file for i18n options
  }
})
Use code with caution.
TypeScript
Phase 2: Componentization and UI Refactoring
Create a Default Layout (layouts/default.vue):
Move the <header> and the <nav id="bottom-nav"> from the original HTML into this file.
The main content area will be replaced with <slot />.
This layout will wrap all pages automatically.
(Revised) Refactor Navigation with Localization:
Create a components/BottomNav.vue component.
Use Nuxt's useLocalePath composable to generate correct localized links. This ensures that when a user is on the French site, links stay within /fr/.
The NuxtLink component and its router-link-active class will handle active state styling automatically.
<!-- components/BottomNav.vue -->
<script setup>
const localePath = useLocalePath();
</script>
<template>
  <nav>
    <NuxtLink :to="localePath('/tarot')" class="nav-btn">...</NuxtLink>
    <NuxtLink :to="localePath('/astrology')" class="nav-btn">...</NuxtLink>
    <!-- etc. -->
  </nav>
</template>
Use code with caution.
Vue
Break Down UI into Components (components/):
AppHeader.vue: Will contain the logo and tagline.
(Revised) LanguageSwitcher.vue: A dedicated component for switching languages. It will use the @nuxtjs/i18n module's switchLocalePath composable.
TarotCard.vue: Manages its own "flipped" state and emits selection events.
ResultDisplay.vue: A generic component to show readings, accepting result data as props.
ZodiacSignButton.vue: For the horoscope section.
AnimationOverlay.vue: Encapsulates the entire full-screen animation logic.
Phase 3: Page Structure and Logic
(Revised) Create the Pages using Dynamic Routing:
Instead of separate files for each tool, we'll use Nuxt 3's dynamic page capabilities for a cleaner structure.
pages/index.vue: This will be the landing page for the default locale (e.g., teller.eu.org/). It can show a welcome message or redirect.
pages/[tool].vue: This single file will handle teller.eu.org/tarot, teller.eu.org/astrology, etc. It will dynamically render the correct tool's content based on the :tool route parameter.
<!-- pages/[tool].vue -->
<script setup>
const route = useRoute();
const toolName = computed(() => route.params.tool); // 'tarot', 'astrology', etc.

// Validate that the tool is valid, otherwise show a 404
const validTools = ['tarot', 'astrology', 'numerology', 'chinese-zodiac'];
if (!validTools.includes(toolName.value)) {
  throw createError({ statusCode: 404, statusMessage: 'Page Not Found' });
}
</script>
<template>
  <div>
    <TarotTool v-if="toolName === 'tarot'" />
    <AstrologyTool v-if="toolName === 'astrology'" />
    <!-- etc. -->
  </div>
</template>
Use code with caution.
Vue
This approach, combined with the i18n config, will automatically create all the necessary routes like /fr/tarot, /zh/astrology, etc.
Data Management:
Move the large static data object (tarot meanings, etc.) into a composable: composables/useDivinationData.ts.
This composable will export functions like getTarotCards(locale) and getHoroscopeFor(sign, locale). The locale will be passed from the page to fetch the correctly translated data.
State Management:
Page-Specific State: Use ref() or reactive() inside each tool's component (e.g., components/tools/TarotTool.vue).
Global State: useState is still the right choice for anything truly global, though @nuxtjs/i18n handles the current language state for us.
(Revised) Business Logic as Composables:
composables/useNumerology.ts: Contains getLifePathNumber() and getDestinyNumber().
composables/useChineseZodiac.ts: Contains zodiac calculation logic.
composables/useShare.ts: Contains shareResult() logic, using process.client to ensure navigator is only accessed on the client side.
Phase 4: Styling and Animations
Styling Strategy:
Global Styles: Move general styles (body, containers, gradients) to assets/css/main.css and register it in nuxt.config.ts.
Scoped Styles: Use <style scoped> within each .vue file to prevent style conflicts. This is a major advantage over the single-file approach.
Animation Integration (anime.js):
Create a client-side Nuxt plugin: plugins/anime.client.ts. This makes anime.js available via the useNuxtApp().$anime helper.
The components/AnimationOverlay.vue component will encapsulate all animation logic. It can be triggered via a reactive prop passed from its parent page.
Phase 5: Finalizing and Enhancements
(Revised) SEO and Metadata:
Utilize Nuxt's useHead composable inside pages/[tool].vue.
Dynamically set the page title and meta description based on the current tool (route.params.tool) and language (useI18n().locale.value). This is crucial for SEO.
<!-- pages/[tool].vue -->
<script setup>
const { t, locale } = useI18n();
const route = useRoute();

useHead(() => ({
  title: t(`seo.${route.params.tool}.title`), // e.g., 'seo.tarot.title'
  meta: [
    { name: 'description', content: t(`seo.${route.params.tool}.description`) }
  ]
}))
</script>
Use code with caution.
Vue
Build and Deployment:
The site remains a perfect candidate for Static Site Generation (SSG).
Run npx nuxi generate. Nuxt will automatically pre-render all possible localized routes (/fr/tarot, /zh/astrology, etc.) into static HTML files.
Deploy the dist/ directory to any static host. You will get top-tier performance and SEO without needing a running server.